[{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/structure/","section":"Structures","summary":"","title":"Structures","type":"structure"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/","section":"Categories","summary":"","title":"编程开发","type":"categories"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/tags/%E9%98%9F%E5%88%97/","section":"Tags","summary":"","title":"队列","type":"tags"},{"content":" 队列 # 定义 # 队列是一种特殊的线性表,他的特殊性在于将线性表的操作限定为表尾插入，表头删除\n通过这个特殊的限定我们可以达到FIFO(first in first out)的目的\n抽象数据类型 # Queue.java\n队列的数组实现（循环队列） # CircleQueue.java\n队列数据存储的问题 # 虽然我们采用数组来作为数据存储的基本结构，但是由于队列的使用过程中头尾指针是动态的。\n所以我们很容一造成头指针到index = 0 之间的空间浪费 因此我们采用 尾指针 = (尾指针 + 1) % data.length的方式来移动尾指针，让尾指针可以循环起来\n这样就解决了存储空间浪费的问题\n尾指针移动的几个问题， # CircleQueue.java#rearMove\n按照正常情况下，队列临界的问题判断应该如下\n# 队列满 this.font == this.rear # 队列空 this.font == this.rear 我们无法区分队列满 和 队列空，需要引入一个新的变量flag来判断。\n我们这里可以使用空出最后一个存储空间的方式来达到该目的，而不用引入新的状态\nthis.rear = ++this.rear % data.length; if (this.rear == this.front){ throw new RuntimeException(\u0026#34;rear is out of size\u0026#34;); } 队列的链表实现实现 # LinkedQueue.java\n","date":"11 September 2024","externalUrl":null,"permalink":"/structure/queue/","section":"Structures","summary":"","title":"队列入门","type":"structure"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/","section":"鲸云🐳","summary":"","title":"鲸云🐳","type":"page"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Series","summary":"","title":"数据结构","type":"series"},{"content":"","date":"11 September 2024","externalUrl":null,"permalink":"/tags/%E6%A0%88/","section":"Tags","summary":"","title":"栈","type":"tags"},{"content":" 栈 # 定义 # 栈是一种特殊的线性表,只可以在线性表的底部进行插入和删除操作.\n线性表的头部被称为栈底,底部被成为栈顶,也就是说栈只可以在栈顶进行插入或者删除操作\n插入操作被称为压栈(push) 删除操作被叫做弹栈(pop). 抽象数据类型 # 数据 # AbstractStack\n行为 # IStack\nIShardedStack.java\n栈的种类 # 数组栈和链表栈 # 因为栈是特殊的线性表，所以很自然的就想到存在数组和链表两种实现方式。 个人觉得数组这种方式特别合适，因为我们限定了所有操作都要在栈顶，而链表方式会多一些额外开销。\n共享栈 # 共享栈就是两个栈分享一个数组/节点链表，栈顶由单个栈的时候的数组最大值，变成了两个栈顶\u0026quot;发生碰撞\u0026quot; 栈的应用 # 递归 # 递归的典型运用场景就是斐波那契数列\n斐波那契数列: 前两项数的和 f(0) = 0; f(1) = 1; f(n) = f(n-1) + f(n-2);\n普通的执行方法如果我们要算f(20),那么要从 f(0) f(1) f(2)一步步计算到f(20);\n使用递归的化我们是从f(20)开始分解公式,f(20) = f(19) + f(18);再去调用f(18) 和 f(19) 依次往下自己调用自己。\n在这个依次向下的调用过程我们就需要 \u0026ldquo;先将上层的公式存起来\u0026rdquo; 先存起来的公式后算,这和栈结构不谋而合，而在java中执行方法的压栈和出栈也确实是这样的。\n四则运算法则 # 我们常见的表达式 9+（3－1）×3+10÷2 叫做中缀表达式，我们可以很轻松的依据优先级 “ 括号 大于 乘除 大于 加减” 来算出结果\n但是计算机在处理中缀表达式的时候就很难办,于是 波兰的一位逻辑学家 想出来了一个后缀(逆波兰)表达式, 而上述中缀表达式转换后未 9 3 1 - 3 * + 10 2 / +\n中缀表达式转后缀表达式 # 中缀表达式提取后缀表达的基本步骤:\n依次读取表达式中的每一项 符号和数字 ，读取到数字则放到后缀表达式中，读取到符号则放入计算符号栈中 如果栈顶 无符号 或者 优先级小于 当前要放入的符号,则直接放入 如果放入的符号 优先级大于当前符号则取出栈中的所有符号加入表达式 再放入符号 如果放入的符号是) 则取出符号直到(为止 加入表达式 然后再放入符号 后缀表达式的计算逻辑 # 依次将每个表达式的元素放入到计算栈中 如果获取到计算符号则从栈中取出两个数进行计算，之后再放入到栈中 最后计算结束取出栈中数据即可 ","date":"11 September 2024","externalUrl":null,"permalink":"/structure/stack/","section":"Structures","summary":"","title":"栈入门","type":"structure"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/menu/","section":"Menus","summary":"","title":"Menus","type":"menu"},{"content":" togally/bookLearning Java 0 0 ","externalUrl":null,"permalink":"/menu/project/","section":"Menus","summary":"","title":"项目","type":"menu"}]